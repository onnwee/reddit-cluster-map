// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crawl_jobs.sql

package db

import (
	"context"
	"database/sql"
)

const crawlJobExists = `-- name: CrawlJobExists :one
SELECT EXISTS (
  SELECT 1 FROM crawl_jobs WHERE subreddit_id = $1 AND status IN ('queued', 'in_progress')
) AS exists
`

func (q *Queries) CrawlJobExists(ctx context.Context, subredditID int32) (bool, error) {
	row := q.db.QueryRowContext(ctx, crawlJobExists, subredditID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const enqueueCrawlJob = `-- name: EnqueueCrawlJob :exec
INSERT INTO crawl_jobs (subreddit_id, status, retries, enqueued_by)
VALUES ($1, 'queued', 0, $2)
ON CONFLICT (subreddit_id) DO NOTHING
`

type EnqueueCrawlJobParams struct {
	SubredditID int32
	EnqueuedBy  sql.NullString
}

func (q *Queries) EnqueueCrawlJob(ctx context.Context, arg EnqueueCrawlJobParams) error {
	_, err := q.db.ExecContext(ctx, enqueueCrawlJob, arg.SubredditID, arg.EnqueuedBy)
	return err
}

const getNextCrawlJob = `-- name: GetNextCrawlJob :one
SELECT id, subreddit_id, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs WHERE status = 'queued' ORDER BY created_at ASC LIMIT 1
`

func (q *Queries) GetNextCrawlJob(ctx context.Context) (CrawlJob, error) {
	row := q.db.QueryRowContext(ctx, getNextCrawlJob)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.SubredditID,
		&i.Status,
		&i.Retries,
		&i.LastAttempt,
		&i.DurationMs,
		&i.EnqueuedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingCrawlJobs = `-- name: GetPendingCrawlJobs :many
SELECT id, subreddit_id, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs
WHERE status = 'queued' OR status = 'in_progress'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingCrawlJobs(ctx context.Context, limit int32) ([]CrawlJob, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCrawlJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrawlJob
	for rows.Next() {
		var i CrawlJob
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.Status,
			&i.Retries,
			&i.LastAttempt,
			&i.DurationMs,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrawlJobs = `-- name: ListCrawlJobs :many
SELECT id, subreddit_id, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs ORDER BY created_at DESC LIMIT $1 OFFSET $2
`

type ListCrawlJobsParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListCrawlJobs(ctx context.Context, arg ListCrawlJobsParams) ([]CrawlJob, error) {
	rows, err := q.db.QueryContext(ctx, listCrawlJobs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrawlJob
	for rows.Next() {
		var i CrawlJob
		if err := rows.Scan(
			&i.ID,
			&i.SubredditID,
			&i.Status,
			&i.Retries,
			&i.LastAttempt,
			&i.DurationMs,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCrawlJobFailed = `-- name: MarkCrawlJobFailed :exec
UPDATE crawl_jobs SET status = 'failed', retries = retries + 1, updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobFailed(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobFailed, id)
	return err
}

const markCrawlJobInProgress = `-- name: MarkCrawlJobInProgress :exec
UPDATE crawl_jobs
SET status = 'in_progress'
WHERE id = $1
`

func (q *Queries) MarkCrawlJobInProgress(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobInProgress, id)
	return err
}

const markCrawlJobStarted = `-- name: MarkCrawlJobStarted :exec
UPDATE crawl_jobs SET status = 'crawling', last_attempt = now(), updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobStarted(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobStarted, id)
	return err
}

const markCrawlJobSuccess = `-- name: MarkCrawlJobSuccess :exec
UPDATE crawl_jobs SET status = 'success', updated_at = now() WHERE id = $1
`

func (q *Queries) MarkCrawlJobSuccess(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobSuccess, id)
	return err
}

const nextCrawlJob = `-- name: NextCrawlJob :one
SELECT id, subreddit_id, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs
WHERE status = 'pending'
ORDER BY created_at
LIMIT 1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) NextCrawlJob(ctx context.Context) (CrawlJob, error) {
	row := q.db.QueryRowContext(ctx, nextCrawlJob)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.SubredditID,
		&i.Status,
		&i.Retries,
		&i.LastAttempt,
		&i.DurationMs,
		&i.EnqueuedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
