// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: crawl_jobs.sql

package db

import (
	"context"
)

const crawlJobExists = `-- name: CrawlJobExists :one
SELECT EXISTS (
  SELECT 1 FROM crawl_jobs WHERE subreddit = $1 AND status IN ('queued', 'in_progress')
) AS exists
`

func (q *Queries) CrawlJobExists(ctx context.Context, subreddit string) (bool, error) {
	row := q.db.QueryRowContext(ctx, crawlJobExists, subreddit)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const enqueueCrawlJob = `-- name: EnqueueCrawlJob :exec
INSERT INTO crawl_jobs (subreddit, status, created_at, updated_at)
VALUES ($1, 'queued', now(), now())
ON CONFLICT (subreddit) DO UPDATE SET
  status = 'queued',
  retries = 0,
  last_attempt = NULL,
  duration_ms = NULL,
  updated_at = now()
`

func (q *Queries) EnqueueCrawlJob(ctx context.Context, subreddit string) error {
	_, err := q.db.ExecContext(ctx, enqueueCrawlJob, subreddit)
	return err
}

const getNextCrawlJob = `-- name: GetNextCrawlJob :one
SELECT id, subreddit, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs
WHERE status = 'queued'
ORDER BY created_at ASC
LIMIT 1
`

func (q *Queries) GetNextCrawlJob(ctx context.Context) (CrawlJob, error) {
	row := q.db.QueryRowContext(ctx, getNextCrawlJob)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.Subreddit,
		&i.Status,
		&i.Retries,
		&i.LastAttempt,
		&i.DurationMs,
		&i.EnqueuedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPendingCrawlJobs = `-- name: GetPendingCrawlJobs :many
SELECT id, subreddit, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs
WHERE status = 'queued' OR status = 'in_progress'
ORDER BY created_at ASC
LIMIT $1
`

func (q *Queries) GetPendingCrawlJobs(ctx context.Context, limit int32) ([]CrawlJob, error) {
	rows, err := q.db.QueryContext(ctx, getPendingCrawlJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrawlJob
	for rows.Next() {
		var i CrawlJob
		if err := rows.Scan(
			&i.ID,
			&i.Subreddit,
			&i.Status,
			&i.Retries,
			&i.LastAttempt,
			&i.DurationMs,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCrawlJobs = `-- name: ListCrawlJobs :many
SELECT id, subreddit, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs ORDER BY created_at DESC LIMIT 100
`

func (q *Queries) ListCrawlJobs(ctx context.Context) ([]CrawlJob, error) {
	rows, err := q.db.QueryContext(ctx, listCrawlJobs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []CrawlJob
	for rows.Next() {
		var i CrawlJob
		if err := rows.Scan(
			&i.ID,
			&i.Subreddit,
			&i.Status,
			&i.Retries,
			&i.LastAttempt,
			&i.DurationMs,
			&i.EnqueuedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markCrawlJobFailed = `-- name: MarkCrawlJobFailed :exec
UPDATE crawl_jobs SET status = 'failed', retries = retries + 1, updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkCrawlJobFailed(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobFailed, id)
	return err
}

const markCrawlJobInProgress = `-- name: MarkCrawlJobInProgress :exec
UPDATE crawl_jobs
SET status = 'in_progress'
WHERE id = $1
`

func (q *Queries) MarkCrawlJobInProgress(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobInProgress, id)
	return err
}

const markCrawlJobStarted = `-- name: MarkCrawlJobStarted :exec
UPDATE crawl_jobs SET status = 'crawling', last_attempt = now(), updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkCrawlJobStarted(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobStarted, id)
	return err
}

const markCrawlJobSuccess = `-- name: MarkCrawlJobSuccess :exec
UPDATE crawl_jobs SET status = 'success', updated_at = now()
WHERE id = $1
`

func (q *Queries) MarkCrawlJobSuccess(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, markCrawlJobSuccess, id)
	return err
}

const nextCrawlJob = `-- name: NextCrawlJob :one
SELECT id, subreddit, status, retries, last_attempt, duration_ms, enqueued_by, created_at, updated_at FROM crawl_jobs
WHERE status = 'pending'
ORDER BY created_at
LIMIT 1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) NextCrawlJob(ctx context.Context) (CrawlJob, error) {
	row := q.db.QueryRowContext(ctx, nextCrawlJob)
	var i CrawlJob
	err := row.Scan(
		&i.ID,
		&i.Subreddit,
		&i.Status,
		&i.Retries,
		&i.LastAttempt,
		&i.DurationMs,
		&i.EnqueuedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
