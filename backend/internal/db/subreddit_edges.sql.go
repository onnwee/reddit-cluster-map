// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: subreddit_edges.sql

package db

import (
	"context"
)

const getEdgesForSubreddit = `-- name: GetEdgesForSubreddit :many
SELECT source, target, shared_users, updated_at, created_at FROM subreddit_edges WHERE source = $1 OR target = $1
`

func (q *Queries) GetEdgesForSubreddit(ctx context.Context, source string) ([]SubredditEdge, error) {
	rows, err := q.db.QueryContext(ctx, getEdgesForSubreddit, source)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubredditEdge
	for rows.Next() {
		var i SubredditEdge
		if err := rows.Scan(
			&i.Source,
			&i.Target,
			&i.SharedUsers,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSubredditEdges = `-- name: ListSubredditEdges :many
SELECT source, target, shared_users, updated_at, created_at FROM subreddit_edges ORDER BY created_at DESC LIMIT 100
`

func (q *Queries) ListSubredditEdges(ctx context.Context) ([]SubredditEdge, error) {
	rows, err := q.db.QueryContext(ctx, listSubredditEdges)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubredditEdge
	for rows.Next() {
		var i SubredditEdge
		if err := rows.Scan(
			&i.Source,
			&i.Target,
			&i.SharedUsers,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopEdges = `-- name: ListTopEdges :many
SELECT source, target, shared_users, updated_at, created_at FROM subreddit_edges ORDER BY shared_users DESC LIMIT $1 OFFSET $2
`

type ListTopEdgesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) ListTopEdges(ctx context.Context, arg ListTopEdgesParams) ([]SubredditEdge, error) {
	rows, err := q.db.QueryContext(ctx, listTopEdges, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SubredditEdge
	for rows.Next() {
		var i SubredditEdge
		if err := rows.Scan(
			&i.Source,
			&i.Target,
			&i.SharedUsers,
			&i.UpdatedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertSubredditEdge = `-- name: UpsertSubredditEdge :exec
INSERT INTO subreddit_edges (source, target, shared_users, updated_at)
VALUES ($1, $2, $3, now())
ON CONFLICT (source, target) DO UPDATE SET
  shared_users = subreddit_edges.shared_users + EXCLUDED.shared_users,
  updated_at = now()
`

type UpsertSubredditEdgeParams struct {
	Source      string
	Target      string
	SharedUsers int32
}

func (q *Queries) UpsertSubredditEdge(ctx context.Context, arg UpsertSubredditEdgeParams) error {
	_, err := q.db.ExecContext(ctx, upsertSubredditEdge, arg.Source, arg.Target, arg.SharedUsers)
	return err
}
